// 008.chpl
// The four adjacent digits in the 1000-digit number
// that have the greatest product are 9 × 9 × 8 × 9 = 5832.
// 
//   73167176531330624919225119674426574742355349194934
//   96983520312774506326239578318016984801869478851843
//   85861560789112949495459501737958331952853208805511
//   12540698747158523863050715693290963295227443043557
//   66896648950445244523161731856403098711121722383113
//
//   62229893423380308135336276614282806444486645238749
//   30358907296290491560440772390713810515859307960866
//   70172427121883998797908792274921901699720888093776
//   65727333001053367881220235421809751254540594752243
//   52584907711670556013604839586446706324415722155397
//
//   53697817977846174064955149290862569321978468622482
//   83972241375657056057490261407972968652414535100474
//   82166370484403199890008895243450658541227588666881
//   16427171479924442928230863465674813919123162824586
//   17866458359124566529476545682848912883142607690042
//
//   24219022671055626321111109370544217506941658960408
//   07198403850962455444362981230987879927244284909188
//   84580156166097919133875499200524063689912560717606
//   05886116467109405077541002256983155200055935729725
//   71636269561882670428252483600823257530420752963450
// 
// Find the thirteen adjacent digits in the 1000-digit number
// that have the greatest product. What is the value of this product?


module Euler008 {

config const adjacentCount_008: int = 13;

// ========== BEGIN SETUP ========== 
var ds: [0..19] string;
ds[0]  = "73167176531330624919225119674426574742355349194934";
ds[1]  = "96983520312774506326239578318016984801869478851843";

ds[2]  = "85861560789112949495459501737958331952853208805511";
ds[3]  = "12540698747158523863050715693290963295227443043557";

ds[4]  = "66896648950445244523161731856403098711121722383113"; 
ds[5]  = "62229893423380308135336276614282806444486645238749";

ds[6]  = "30358907296290491560440772390713810515859307960866";
ds[7]  = "70172427121883998797908792274921901699720888093776";

ds[8]  = "65727333001053367881220235421809751254540594752243";
ds[9]  = "52584907711670556013604839586446706324415722155397";



ds[10] = "53697817977846174064955149290862569321978468622482";
ds[11] = "83972241375657056057490261407972968652414535100474";

ds[12] = "82166370484403199890008895243450658541227588666881";
ds[13] = "16427171479924442928230863465674813919123162824586";

ds[14] = "17866458359124566529476545682848912883142607690042";
ds[15] = "24219022671055626321111109370544217506941658960408";
 
ds[16] = "07198403850962455444362981230987879927244284909188";
ds[17] = "84580156166097919133875499200524063689912560717606";

ds[18] = "05886116467109405077541002256983155200055935729725";
ds[19] = "71636269561882670428252483600823257530420752963450";
 
var dig_str = "".join(ds);
var len = dig_str.length;
const indices: domain(1) = {1 .. len};
const digits: [indices] int = [i in indices] (dig_str[i]: int);
// ========== END SETUP ========== 

proc getPeakIndex(digits, adj) {
  var peakIndex = -1;
  var maxProduct = 0;
  for i in 1 .. (len - adj) {
    var product = * reduce digits[i .. (i + adj - 1)];
    if (product > maxProduct) {
      peakIndex = i;
      maxProduct = product;
    }
  }
  return peakIndex;
}

proc getMaxProduct(digits, adj, peakIndex) {
  return * reduce digits[peakIndex .. (peakIndex + adj - 1)];
}

proc displayResults(digits, adj) {
  var peakIndex = getPeakIndex(digits, adj);
  write("From 1-based index=", peakIndex, ": ");
  var sep = "";
  for i in peakIndex .. (peakIndex + adj - 1) {
    write(sep, digits[i]);
    sep = ",";
  };
  writeln("");
  writeln("Product=", getMaxProduct(digits, adj, peakIndex));
}

proc main() {
  // test();
  var adj = adjacentCount_008;

  displayResults(digits, adj);
}

proc test() {
  var test_adj = 4;
  var test_result = 5832;

  assert(
    getMaxProduct(digits, test_adj, getPeakIndex(digits, test_adj))
      == test_result
  );
}

}

